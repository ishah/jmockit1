/*
 * Copyright (c) 2006 Rog��rio Liesenfeld
 * This file is subject to the terms of the MIT license (see LICENSE.txt).
 */
package mockit.internal.state;

import javax.annotation.*;

import mockit.internal.expectations.*;
import mockit.internal.expectations.mocking.*;
import mockit.internal.mockups.*;
import mockit.internal.util.*;

/**
 * A singleton which stores several data structures which in turn hold global state for individual test methods, test
 * classes, and for the test run as a whole.
 */
public final class TestRun
{
   //private static final TestRun INSTANCE = new TestRun();
   private static final InheritableThreadLocal<TestRun> INSTANCES = new InheritableThreadLocal<TestRun>() {
	          @Override protected TestRun initialValue() {
	              return new TestRun();
	          }
	       };
   private TestRun() {}

   // Fields with global state ////////////////////////////////////////////////////////////////////////////////////////

   private static final ThreadLocal<Integer> noMockingCount = new ThreadLocal<Integer>() {
      @Override protected Integer initialValue() { return 0; }
      @Override public void set(Integer valueToAdd) { super.set(get() + valueToAdd); }
   };

   // Used only by the Coverage tool:
   private int testId;

   @Nullable private Class<?> currentTestClass;
   @Nullable private Object currentTestInstance;
   @Nullable private FieldTypeRedefinitions fieldTypeRedefinitions;

   @Nonnull private final MockFixture mockFixture = new MockFixture();

   @Nonnull private final ExecutingTest executingTest = new ExecutingTest();
   @Nonnull private final MockClasses mockClasses = new MockClasses();

   // Static "getters" for global state ///////////////////////////////////////////////////////////////////////////////

   public static boolean isInsideNoMockingZone() { return noMockingCount.get() > 0; }

   @Nullable public static Class<?> getCurrentTestClass() { return INSTANCES.get().currentTestClass; }

   @Nullable public static Object getCurrentTestInstance() { return INSTANCES.get().currentTestInstance; }

   @SuppressWarnings("unused")
   public static int getTestId() { return INSTANCES.get().testId; }

   @Nullable
   public static FieldTypeRedefinitions getFieldTypeRedefinitions() { return INSTANCES.get().fieldTypeRedefinitions; }

   @Nonnull public static MockFixture mockFixture() { return INSTANCES.get().mockFixture; }

   @Nonnull public static ExecutingTest getExecutingTest() { return INSTANCES.get().executingTest; }

   @Nullable public static RecordAndReplayExecution getRecordAndReplayForRunningTest()
   {
      return INSTANCES.get().executingTest.getCurrentRecordAndReplay();
   }

   @Nonnull
   public static RecordAndReplayExecution getOrCreateRecordAndReplayForRunningTest()
   {
      return INSTANCES.get().executingTest.getOrCreateRecordAndReplay();
   }

   @Nonnull
   public static RecordAndReplayExecution getRecordAndReplayForVerifications()
   {
      if (INSTANCES.get().fieldTypeRedefinitions == null) {
         IllegalStateException failure = new IllegalStateException("Invalid place to verify expectations");
         StackTrace.filterStackTrace(failure);
         throw failure;
      }

      return INSTANCES.get().executingTest.getRecordAndReplayForVerifications();
   }

   @Nonnull public static MockClasses getMockClasses() { return INSTANCES.get().mockClasses; }
   @Nonnull public static MockStates getMockStates() { return INSTANCES.get().mockClasses.mockStates; }

   // Static "mutators" for global state //////////////////////////////////////////////////////////////////////////////

   public static void setCurrentTestClass(@Nullable Class<?> testClass)
   {
      INSTANCES.get().currentTestClass = testClass;
   }

   public static void prepareForNextTest()
   {
      INSTANCES.get().testId++;
      INSTANCES.get().executingTest.setRecordAndReplay(null);
   }

   public static void enterNoMockingZone() { noMockingCount.set(1); }
   public static void exitNoMockingZone()  { noMockingCount.set(-1); }
   public static void clearNoMockingZone() { noMockingCount.remove(); }

   public static void setRunningIndividualTest(@Nullable Object testInstance)
   {
      INSTANCES.get().currentTestInstance = testInstance;
   }

   public static void setFieldTypeRedefinitions(@Nullable FieldTypeRedefinitions redefinitions)
   {
      INSTANCES.get().fieldTypeRedefinitions = redefinitions;
   }

   public static void finishCurrentTestExecution()
   {
      INSTANCES.get().executingTest.finishExecution();
    //  INSTANCES.set(new TestRun());
   }

   // Methods to be called only from generated bytecode or from the MockingBridge /////////////////////////////////////

   @SuppressWarnings("StaticMethodOnlyUsedInOneClass")
   public static boolean updateMockState(
      @Nonnull String mockUpClassDesc, @Nullable Object mockedInstance, int mockStateIndex)
   {
      Object mockUp = getMock(mockUpClassDesc, mockedInstance);

      if (mockUp == null) {
         return false;
      }

      if (mockStateIndex < 0) {
         return true;
      }

      return getMockStates().updateMockState(mockUp, mockStateIndex);
   }

   @Nullable
   public static Object getMock(@Nonnull String mockUpClassDesc, @Nullable Object mockedInstance)
   {
      return INSTANCES.get().mockClasses.getMock(mockUpClassDesc, mockedInstance);
   }
}
